<!doctype html>
<html lang="cs">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mobiln√≠ Oper√°tor Tycoon ‚Äî Prototyp</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  html, body,#map{height:100%;margin:0;padding:0;font-family:Inter, Arial, sans-serif}
  .hud{position:absolute;left:10px;top:10px;z-index:1100;background:rgba(255,255,255,0.95);padding:8px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.15)}
  .hud div{margin:4px 0}
  .hamburger{position:absolute;right:10px;top:10px;z-index:1200}
  .hamburger button{background:#111;color:#fff;border:none;padding:10px;border-radius:8px;cursor:pointer}
  .menu{position:absolute;right:10px;top:56px;z-index:1200;background:rgba(255,255,255,0.98);padding:12px;border-radius:8px;box-shadow:0 2px 12px rgba(0,0,0,0.2);display:none}
  .menu h3{margin:0 0 8px 0}
  .menu button{display:block;margin:6px 0;padding:8px;border-radius:6px;border:none;background:#333;color:#fff;cursor:pointer;transition:background 0.2s}
  .menu button:hover{background:#555}
  .legend{position:absolute;left:10px;bottom:10px;z-index:1100;background:rgba(255,255,255,0.95);padding:8px;border-radius:8px}
  .legend div{display:flex;align-items:center;margin:4px}
  .sw{width:18px;height:12px;margin-right:8px;border-radius:3px}
</style>
</head>
<body>
<div id="map"></div>
<div class="hud" id="hud">
  <div><strong>Penƒõz:</strong> <span id="money">2000000</span> Kƒç</div>
  <div><strong>Z√°kazn√≠k≈Ø:</strong> <span id="customers">0</span></div>
  <div><strong>P≈ô√≠jem/s:</strong> <span id="income">0</span> Kƒç/s</div>
</div>
<div class="hamburger">
  <button id="hambBtn">‚ò∞ Menu</button>
  <div class="menu" id="menu">
    <h3>Akce</h3>
    <button id="addTxBtn">Postavit vys√≠laƒç</button>
    <button id="addShopBtn">Postavit poboƒçku</button>
    <button id="promoBtn">Spustit promo (sleva)</button>
    <hr />
    <div style="font-size:12px;color:#fff">Tip: Klikni na mapu pro um√≠stƒõn√≠ objektu po zvolen√≠ akce.</div>
  </div>
</div>
<div class="legend">
  <div><div class="sw" style="background:#006400"></div> V√Ωborn√Ω</div>
  <div><div class="sw" style="background:#2ecc71"></div> Velmi dobr√Ω</div>
  <div><div class="sw" style="background:#f1c40f"></div> Dobr√Ω</div>
  <div><div class="sw" style="background:#e67e22"></div> u≈æ nic moc</div>
  <div><div class="sw" style="background:#e74c3c"></div> slab√Ω</div>
  <div><div class="sw" style="background:#800000"></div> ≈æ√°dn√Ω</div>
  <button onclick="clearGame()">Vymazat ulo≈æenou hru</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Turf can remain loaded if you still need it elsewhere, but coverage now uses internal haversine -->
<script>
let money = 2000000;
let customers = 0;
let incomePerCustomerPerSec = 0.2;
const prahaCenter = [50.0833067, 14.3866611];
const map = L.map('map').setView(prahaCenter, 12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);

// üîÅ Schov√°v√°n√≠ ikon vys√≠laƒç≈Ø p≈ôi odd√°len√≠
map.on('zoomend', () => {
  const zoom = map.getZoom();
  if (zoom < 11) {
    map.removeLayer(txLayer); // schov√° v≈°echny vys√≠laƒçe
  } else {
    if (!map.hasLayer(txLayer)) map.addLayer(txLayer); // znovu je zobraz√≠
  }
});

const txLayer = L.layerGroup().addTo(map);
const shopLayer = L.layerGroup().addTo(map);
const coverageLayer = L.layerGroup().addTo(map); // sem budeme p≈ôid√°vat jedin√Ω imageOverlay

let coverageImageOverlay = null; // dr≈æ√≠ aktu√°ln√≠ L.imageOverlay

const moneyEl = document.getElementById('money');
const custEl = document.getElementById('customers');
const incomeEl = document.getElementById('income');
const menuEl = document.getElementById('menu');

document.getElementById('hambBtn').addEventListener('click', ()=>{menuEl.style.display = menuEl.style.display==='block'?'none':'block'});

let mode = null;
let pendingTxPower = 25;

document.getElementById('addTxBtn').addEventListener('click', ()=>{
  mode = 'tx';
  pendingTxPower = parseInt(prompt('Zadej v√Ωkon vys√≠laƒçe (5,10,20,25) W','25')) || 10;
  alert('Klikni na mapu pro um√≠stƒõn√≠ vys√≠laƒçe.');
});

document.getElementById('addShopBtn').addEventListener('click', ()=>{
  mode = 'shop';
  alert('Klikni na mapu pro um√≠stƒõn√≠ poboƒçky.');
});

document.getElementById('promoBtn').addEventListener('click', ()=>{runPromo();});

map.on('click', (e)=>{
  if(mode==='tx'){
    const cost = costForTx(pendingTxPower);
    if(money<cost){alert('Nem√°≈° dost penƒõz na tento vys√≠laƒç.'); return}
    money -= cost; updateHUD(); addTransmitter(e.latlng, pendingTxPower);
    mode=null; menuEl.style.display='none';
  } else if(mode==='shop'){
    const cost=50000;
    if(money<cost){alert('Nem√°≈° dost penƒõz na poboƒçku.'); return}
    money -= cost; updateHUD(); addShop(e.latlng);
    mode=null; menuEl.style.display='none';
  }
});

function costForTx(power) {
  if (power <= 5) return 10000;
  if (power >= 25) return 100000;

  const minPower = 5, maxPower = 25;
  const minCost = 10000, maxCost = 100000;
  const exponent = 1.5; // >1 = rostouc√≠ rychleji, <1 = pomaleji

  let normalized = (power - minPower) / (maxPower - minPower);
  let cost = minCost + Math.pow(normalized, exponent) * (maxCost - minCost);

  return Math.round(cost);
}

function addTransmitter(latlng, power){
  const txIcon = L.icon({
    iconUrl: 'https://i.imgur.com/v3yKg3b.png', // tv≈Øj obr√°zek
    iconSize: [32, 32], // velikost ikony (px)
    iconAnchor: [16, 32], // bod, kter√Ω bude p≈ôesnƒõ na sou≈ôadnici markeru (st≈ôed spodn√≠ ƒç√°sti)
    popupAnchor: [0, -32] // kde se otev≈ôe popup v≈Øƒçi ikonƒõ
  });

  const marker = L.marker(latlng, {
    title: `Vys√≠laƒç ${power}W`,
    icon: txIcon
  }).addTo(txLayer);

  marker.bindPopup(`<b>Vys√≠laƒç</b><br>${power} W`);
  computeCoverage();
}

function addShop(latlng){
  const marker = L.marker(latlng,{title:'Poboƒçka',icon:L.divIcon({className:'shop-icon',html:'üè¨',iconSize:[28,28]})}).addTo(shopLayer);
  marker.bindPopup('<b>Poboƒçka</b>');
  customers += 500; updateHUD();
}

// --- debounce helper ---
function debounce(func, wait = 100) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  }
}

// --- BARVY a BANDS (ponech√°no z p≈Øvodn√≠ho) ---
const baseColors = ['#00ff00', '#ffff00', '#ffa500', '#ff0000'];
const colorBands = [];
for (let i = 0; i < baseColors.length - 1; i++) {
  let start = hexToRgb(baseColors[i]);
  let end = hexToRgb(baseColors[i + 1]);
  for (let j = 0; j < 5; j++) {
    let t = j / 4;
    let r = Math.round(start.r + (end.r - start.r) * t);
    let g = Math.round(start.g + (end.g - start.g) * t);
    let b = Math.round(start.b + (end.b - start.b) * t);
    colorBands.push(rgbToHex(r, g, b));
  }
}
colorBands.push(baseColors[baseColors.length - 1]);

// --- sign√°l parametry (ponech√°no) ---
const signalScale = 12; // km
const decay = 1.8;
const noiseStrength = 0.25;
const overlapFactor = 0.9;

// --- pomocn√© funkce ---
// NOV√Å FUNKCE: haversine (vzd√°lenost v km)
function haversineKm(lat1, lon1, lat2, lon2){
  const R = 6371;
  const toRad = v => v * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// NOV√Å FUNKCE: map value totalSignal -> color index
function getColorForSignal(totalSignal){
  const norm = Math.log1p(totalSignal) * 5;
  const idx = Math.max(0, Math.min(colorBands.length - 1, colorBands.length - 1 - Math.floor(norm)));
  return colorBands[idx];
}

// NOV√Å FUNKCE: vr√°t√≠ rgba string z hex + opacity
function hexToRgba(hex, opacity=0.4){
  const rgb = hexToRgb(hex);
  return `rgba(${rgb.r},${rgb.g},${rgb.b},${opacity})`;
}

// --- ZMƒöNƒöNO: computeCoverage p≈ôeps√°no na canvas overlay ---
function computeCoverage() {
  // sbƒõr vys√≠laƒç≈Ø do m√≠stn√≠ struktury
  const txs = [];
  txLayer.eachLayer(l => {
    txs.push({
      lat: l.getLatLng().lat,
      lng: l.getLatLng().lng,
      power: parseInt(l.options.title?.match(/(\d+)/)?.[0] || 10)
    });
  });
  // pokud ≈æ√°dn√© vys√≠laƒçe, sma≈æeme overlay
  if (txs.length === 0) {
    coverageLayer.clearLayers();
    coverageImageOverlay = null;
    return;
  }

  // viewport bounds
  const bounds = map.getBounds();
  const south = bounds.getSouth();
  const north = bounds.getNorth();
  const west = bounds.getWest();
  const east = bounds.getEast();

  // dynamick√© rozli≈°en√≠ canvasu podle zoom a velikosti viewportu
  // c√≠lem: ~200-400 pixel≈Ø na del≈°√≠ rozmƒõr (≈ô√≠d√≠ kvalitu vs v√Ωkon)
  const size = map.getSize();
  const longer = Math.max(size.x, size.y);
  let canvasLongPx;
  const zoom = map.getZoom();
  if (zoom < 10) canvasLongPx = 200;
  else if (zoom < 12) canvasLongPx = 300;
  else canvasLongPx = 400;

  // urƒç√≠me ≈°√≠≈ôku/v√Ω≈°ku canvasu v pixelech
  const aspect = size.x / size.y;
  const canvasWidth = Math.round(canvasLongPx * aspect);
  const canvasHeight = Math.round(canvasLongPx / aspect);

  // omez√≠me max pixel count (bezpeƒçnost)
  const maxPixels = 400 * 400;
  let finalWidth = canvasWidth;
  let finalHeight = canvasHeight;
  if (canvasWidth * canvasHeight > maxPixels) {
    const scale = Math.sqrt((canvasWidth * canvasHeight) / maxPixels);
    finalWidth = Math.round(canvasWidth / scale);
    finalHeight = Math.round(canvasHeight / scale);
  }

  // Vytvo≈ô√≠me canvas a vykresl√≠me sign√°l do nƒõj (po pixelech)
  const canvas = document.createElement('canvas');
  canvas.width = finalWidth;
  canvas.height = finalHeight;
  const ctx = canvas.getContext('2d');

  // p≈ôedpoƒç√≠t√°me delty pro p≈ôepoƒçet pixel -> lat/lng
  const latSpan = north - south;
  const lngSpan = east - west;

  // pro ka≈æd√Ω pixel (x,y) spoƒç√≠t√°me odpov√≠daj√≠c√≠ lat/lng a sign√°l
  // iterujeme po pixelech; pokud je to p≈ô√≠li≈° pomal√©, m≈Ø≈æeme dƒõlat skoky (downsampling) ‚Äî teƒè m√°me rozumn√© maximum
  const imgData = ctx.createImageData(finalWidth, finalHeight);
  const data = imgData.data;

  for (let y = 0; y < finalHeight; y++) {
    // map y -> lat (north -> south)
    const lat = north - (y + 0.5) / finalHeight * latSpan;
    for (let x = 0; x < finalWidth; x++) {
      const lng = west + (x + 0.5) / finalWidth * lngSpan;

      // spoƒç√≠tat totalSignal
      let totalSignal = 0;
      for (let i = 0; i < txs.length; i++) {
        const t = txs[i];
        const dist = haversineKm(lat, lng, t.lat, t.lng);
        if (dist > signalScale) continue;
        let signal = t.power / Math.pow(Math.max(dist, 0.05), decay);
        // noise (tro≈°ka variability) - mal√°, necha to vypadat ≈æivƒõ
        signal *= (1 - noiseStrength / 2 + Math.random() * noiseStrength);
        if (dist < signalScale / 4) signal *= 1.2;
        totalSignal += signal * overlapFactor;
      }

      // zvol barvu podle totalSignal
      const hex = getColorForSignal(totalSignal);
      const rgba = hexToRgb(hex);
      // fix opacity (p≈Øvodnƒõ 0.4)
      const opacity = 0.4;

      const idx = (y * finalWidth + x) * 4;
      data[idx] = rgba.r;
      data[idx + 1] = rgba.g;
      data[idx + 2] = rgba.b;
      // mapujeme opacity tak, aby slab√© sign√°ly byly pr≈Øhlednƒõj≈°√≠:
      // men≈°√≠ totalSignal => men≈°√≠ alfa (ale ne √∫plnƒõ 0, aby bylo vizu√°lnƒõ ƒçiteln√©)
      const alpha = Math.max(0, Math.min(1, opacity * Math.min(1, Math.log1p(totalSignal + 1))));
      data[idx + 3] = Math.round(alpha * 255);
    }
  }

  ctx.putImageData(imgData, 0, 0);

  // vytvo≈ô√≠me imageOverlay s t√≠mto canvases a p≈ôid√°me do coverageLayer
  // pou≈æijeme bounds pro um√≠stƒõn√≠ overlayu p≈ôesnƒõ p≈ôes viewport
  const imgBounds = [[north, west], [south, east]];
  // odstran√≠me star√Ω overlay
  coverageLayer.clearLayers();
  if (coverageImageOverlay) {
    try { map.removeLayer(coverageImageOverlay); } catch(e) {}
    coverageImageOverlay = null;
  }
  // konvertujeme canvas na dataURL
  const dataUrl = canvas.toDataURL('image/png');
  coverageImageOverlay = L.imageOverlay(dataUrl, imgBounds, { interactive: false, opacity: 1 }).addTo(coverageLayer);
}

// debounce wrapper (ponech√°no p≈Øvodn√≠)
const computeCoverageDebounced = debounce(computeCoverage, 150);

map.on('moveend', computeCoverageDebounced);
map.on('zoomend', computeCoverageDebounced);

function hexToRgb(hex){
  let num = parseInt(hex.replace('#',''),16);
  return {r:(num>>16)&255, g:(num>>8)&255, b:num&255};
}

function rgbToHex(r,g,b){
  return '#' + [r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('');
}

function updateHUD(){
  moneyEl.textContent = Math.round(money).toLocaleString('cs-CZ');
  custEl.textContent = Math.round(customers).toLocaleString('cs-CZ');
  incomeEl.textContent = (customers*incomePerCustomerPerSec).toFixed(2);
}

// pak v intervalu p≈ô√≠jm≈Ø penƒõz
setInterval(() => {
  const income = customers * incomePerCustomerPerSec;
  money += income;
  updateHUD();
  checkCountryExpansion();
}, 1000);

// P≈ôirozen√Ω r≈Øst z√°kazn√≠k≈Ø ‚Äì jemnƒõj≈°√≠ inkrement
let customerAccumulator = 0;

setInterval(() => {
  const towers = txLayer.getLayers().length;
  const growthRate = 0.1; // z√°kazn√≠k≈Ø za sekundu na vƒõ≈æ (zmƒõ≈à t≈ôeba na 0.05)

  customerAccumulator += towers * growthRate;

  // P≈ôid√°me jen cel√© z√°kazn√≠ky a zbytek si nech√°me na p≈ô√≠≈°tƒõ
  if (customerAccumulator >= 1) {
    const whole = Math.floor(customerAccumulator);
    customers += whole;
    customerAccumulator -= whole;
    updateHUD();
  }
}, 1000);

function runPromo(){
  const cost=200000;
  if(money<cost){alert('Nem√°≈° dost penƒõz na promo.'); return}
  money-=cost; updateHUD();
  customers+=1000; updateHUD();
  setTimeout(()=>{customers-=1000;},20000);
}

// --- seznam milestone pro odemyk√°n√≠ zem√≠ ---
let countryMilestones = [
{ name: 'Slovensko', cost: 30_000_000, unlocked: false },
{ name: 'Rakousko', cost: 60_000_000, unlocked: false },
{ name: 'Maƒèarsko', cost: 100_000_000, unlocked: false },
{ name: 'Slovinsko', cost: 200_000_000, unlocked: false },
{ name: 'Litva', cost: 250_000_000, unlocked: false },
{ name: 'Loty≈°sko', cost: 300_000_000, unlocked: false },
{ name: 'Estonsko', cost: 350_000_000, unlocked: false },
{ name: 'Polsko', cost: 400_000_000, unlocked: false },
{ name: 'Chorvatsko', cost: 450_000_000, unlocked: false },
{ name: 'Nƒõmecko', cost: 500_000_000, unlocked: false },
{ name: '≈†v√Ωcarsko', cost: 550_000_000, unlocked: false },
{ name: 'It√°lie', cost: 600_000_000, unlocked: false },
{ name: 'Holandsko', cost: 650_000_000, unlocked: false },
{ name: 'Belgie & Lucembursko', cost: 700_000_000, unlocked: false },
{ name: 'UK', cost: 750_000_000, unlocked: false },
{ name: 'Irsko', cost: 780_000_000, unlocked: false },
{ name: '≈†v√©dsko', cost: 800_000_000, unlocked: false },
{ name: 'D√°nsko', cost: 820_000_000, unlocked: false },
{ name: 'Finsko', cost: 850_000_000, unlocked: false },
{ name: 'Norsko', cost: 900_000_000, unlocked: false },
{ name: 'Rumunsko a Mold√°vie', cost: 950_000_000, unlocked: false },
{ name: 'Francie', cost: 1_000_000_000, unlocked: false },
{ name: 'Bulharsko', cost: 1_100_000_000, unlocked: false },
{ name: '≈†panƒõlsko', cost: 1_200_000_000, unlocked: false },
{ name: 'Portugalsko', cost: 1_300_000_000, unlocked: false },
{ name: '≈òecko', cost: 1_400_000_000, unlocked: false },
{ name: 'Turecko', cost: 1_500_000_000, unlocked: false },
{ name: 'Balk√°n bundle (Bosna, Srbsko, ƒåern√° Hora, Kosovo, Alb√°nie, Makedonie)', cost: 1_555_000_000, unlocked: false },
{ name: 'Austr√°lie', cost: 1_600_000_000, unlocked: false },
{ name: 'Kanada', cost: 1_800_000_000, unlocked: false },
{ name: 'USA', cost: 2_000_000_000, unlocked: false },
{ name: 'Malajsie', cost: 2_500_000_000, unlocked: false },
{ name: 'Indon√©sie', cost: 2_700_000_000, unlocked: false },
{ name: 'ƒå√≠na', cost: 3_000_000_000, unlocked: false },
{ name: 'Indie', cost: 5_000_000_000, unlocked: false }
];

// --- kontrola a odemyk√°n√≠ zem√≠ ---
function checkCountryExpansion() {
  for (let i = countryMilestones.length - 1; i >= 0; i--) { // iterujeme odzadu pro bezpeƒçn√© maz√°n√≠
    const milestone = countryMilestones[i];
    if (!milestone.unlocked && money >= milestone.cost) {
      if (confirm(`Vl√°da ${milestone.name} v√°s po≈æ√°dala o vybudov√°n√≠ s√≠tƒõ. Licence stoj√≠ ${milestone.cost.toLocaleString()} Kƒç. Chce≈° ji koupit?`)) {
        money = 0; // reset po zakoupen√≠
        milestone.unlocked = true;
        alert(`Gratulace! Nyn√≠ m≈Ø≈æe≈° budovat s√≠≈• na ${milestone.name}.`);
        // odstran√≠me ze seznamu, aby se u≈æ nekontrolovalo
        countryMilestones.splice(i, 1);
      }
    }
  }
}

addTransmitter(L.latLng(prahaCenter[0]+0.01,prahaCenter[1]+0.01),10);
updateHUD();

// --- IndexedDB pro hru Mobiln√≠ Oper√°tor Tycoon ---
const DB_NAME = 'MobOperatorDB';
const DB_VERSION = 1;
let db;

// Inicializace DB
function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onupgradeneeded = (e) => {
      db = e.target.result;
      if (!db.objectStoreNames.contains('txs')) db.createObjectStore('txs', { keyPath: 'id', autoIncrement: true });
      if (!db.objectStoreNames.contains('shops')) db.createObjectStore('shops', { keyPath: 'id', autoIncrement: true });
      if (!db.objectStoreNames.contains('meta')) db.createObjectStore('meta', { keyPath: 'key' });
    };

    request.onsuccess = (e) => { db = e.target.result; resolve(); };
    request.onerror = (e) => reject(e);

  });
}

// Ulo≈æen√≠ hry do IndexedDB
async function saveGame() {
  if (!db) await initDB();
  const tx = db.transaction(['txs', 'shops', 'meta'], 'readwrite');
  const txStore = tx.objectStore('txs');
  const shopStore = tx.objectStore('shops');
  const metaStore = tx.objectStore('meta');

  // Vyƒçistit star√° data
  txStore.clear();
  shopStore.clear();

  // Vys√≠laƒçe
  txLayer.eachLayer(l => {
    txStore.add({
      latlng: l.getLatLng(),
      power: parseInt(l.options.title?.match(/(\d+)/)?.[0] || 10)
    });
  });

  // Poboƒçky
  shopLayer.eachLayer(l => {
    shopStore.add({ latlng: l.getLatLng() });
  });

  // Meta data (pen√≠ze, z√°kazn√≠ci)
  metaStore.put({ key: 'state', money, customers });

  console.log('IndexedDB: stav ulo≈æen');
}

// Naƒçten√≠ hry z IndexedDB
async function loadGame() {
  if (!db) await initDB();
  const tx = db.transaction(['txs', 'shops', 'meta'], 'readonly');
  const txStore = tx.objectStore('txs');
  const shopStore = tx.objectStore('shops');
  const metaStore = tx.objectStore('meta');

  // Naƒç√≠st meta data
  const metaReq = metaStore.get('state');
  metaReq.onsuccess = () => {
    const meta = metaReq.result;
    if (meta) {
      money = meta.money || 200000;
      customers = meta.customers || 1000;
      updateHUD();
    }
  };

  // Naƒç√≠st vys√≠laƒçe
  txStore.openCursor().onsuccess = (e) => {
    const cursor = e.target.result;
    if (cursor) {
      const { latlng, power } = cursor.value;
      addTransmitter(latlng, power);
      cursor.continue();
    }
  };

  // Naƒç√≠st poboƒçky
  shopStore.openCursor().onsuccess = (e) => {
    const cursor = e.target.result;
    if (cursor) {
      const { latlng } = cursor.value;
      addShop(latlng);
      cursor.continue();
    }
  };

  console.log('IndexedDB: hra naƒçtena');
}

async function clearGame() {
  if (!db) await initDB();
  const tx = db.transaction(['txs', 'shops', 'meta'], 'readwrite');
  tx.objectStore('txs').clear();
  tx.objectStore('shops').clear();
  tx.objectStore('meta').clear();
  console.log('IndexedDB: vymaz√°no');
}

setInterval(saveGame, 60000); // 60000 ms = 60 s
loadGame();
updateHUD();
computeCoverage();

</script>
</body>
</html>